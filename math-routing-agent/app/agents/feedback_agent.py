import json
import dspy
from datetime import datetime
from typing import Dict, Any
from app.config import Config

try:
    lm = dspy.OpenAI(model='gpt-3.5-turbo', api_key=Config.OPENAI_API_KEY)
    dspy.configure(lm=lm)
    DSPY_AVAILABLE = True
except:
    DSPY_AVAILABLE = False

class FeedbackSignature(dspy.Signature if DSPY_AVAILABLE else object):
    """DSPy signature for feedback processing"""
    original_question: str = dspy.InputField(desc="Original mathematical question")
    generated_solution: str = dspy.InputField(desc="Solution generated by the system")
    human_feedback: str = dspy.InputField(desc="Feedback provided by human")
    improved_solution: str = dspy.OutputField(desc="Improved solution based on feedback")

class HumanFeedbackAgent:
    def __init__(self):
        self.feedback_storage = "storage/feedback_data.json"
        self.dspy_available = DSPY_AVAILABLE
        
        if DSPY_AVAILABLE:
            self.feedback_processor = dspy.Predict(FeedbackSignature)
        else:
            self.feedback_processor = None
        
        self._ensure_storage()
    
    def _ensure_storage(self):
        """Ensure feedback storage exists"""
        import os
        os.makedirs('storage', exist_ok=True)
        if not os.path.exists(self.feedback_storage):
            with open(self.feedback_storage, 'w') as f:
                json.dump({"feedback_entries": [], "learning_cycles": 0}, f)
    
    def process_feedback(self, question: str, solution: Dict, feedback: str) -> Dict[str, Any]:
        """Process human feedback with learning capabilities"""
        try:
            improved_solution = None
            
            if self.dspy_available and self.feedback_processor:
                # Use DSPy to generate improved solution
                prediction = self.feedback_processor(
                    original_question=question,
                    generated_solution=str(solution),
                    human_feedback=feedback
                )
                improved_solution = prediction.improved_solution
            else:
                # Simple improvement
                improved_solution = f"Improved solution based on your feedback: {feedback}"
            
            # Store feedback for continuous learning
            learning_applied = self._store_feedback(question, solution, feedback, improved_solution)
            
            return {
                "success": True,
                "improved_solution": improved_solution,
                "learning_applied": learning_applied,
                "dspy_used": self.dspy_available
            }
            
        except Exception as e:
            return {
                "success": False,
                "error": str(e)
            }
    
    def _store_feedback(self, question: str, solution: Dict, feedback: str, improved_solution: str) -> bool:
        """Store feedback and update learning"""
        try:
            with open(self.feedback_storage, 'r') as f:
                data = json.load(f)
            
            feedback_entry = {
                "timestamp": datetime.now().isoformat(),
                "question": question,
                "original_solution": solution,
                "human_feedback": feedback,
                "improved_solution": improved_solution,
                "feedback_quality": self._analyze_feedback_quality(feedback)
            }
            
            data["feedback_entries"].append(feedback_entry)
            data["learning_cycles"] += 1
            
            # Implement simple learning: after 5 quality feedbacks, mark as learned
            quality_feedbacks = [f for f in data["feedback_entries"] if f.get("feedback_quality") == "high"]
            learning_applied = len(quality_feedbacks) >= 5
            
            with open(self.feedback_storage, 'w') as f:
                json.dump(data, f, indent=2)
            
            return learning_applied
            
        except Exception as e:
            print(f"Error storing feedback: {e}")
            return False
    
    def _analyze_feedback_quality(self, feedback: str) -> str:
        """Analyze feedback quality for learning"""
        feedback_lower = feedback.lower()
        
        positive_indicators = ['good', 'excellent', 'accurate', 'correct', 'helpful', 'clear']
        constructive_indicators = ['should', 'could', 'better', 'improve', 'suggest']
        
        positive_count = sum(1 for indicator in positive_indicators if indicator in feedback_lower)
        constructive_count = sum(1 for indicator in constructive_indicators if indicator in feedback_lower)
        
        if positive_count >= 2 or constructive_count >= 2:
            return "high"
        elif positive_count >= 1 or constructive_count >= 1:
            return "medium"
        else:
            return "low"
    
    def get_feedback_stats(self) -> Dict[str, Any]:
        """Get feedback statistics and learning progress"""
        try:
            with open(self.feedback_storage, 'r') as f:
                data = json.load(f)
            
            entries = data.get("feedback_entries", [])
            quality_feedbacks = [f for f in entries if f.get("feedback_quality") == "high"]
            
            return {
                "total_feedback_entries": len(entries),
                "quality_feedbacks": len(quality_feedbacks),
                "learning_cycles": data.get("learning_cycles", 0),
                "learning_progress": f"{len(quality_feedbacks)}/5 quality feedbacks collected",
                "system_improving": len(quality_feedbacks) >= 3
            }
        except:
            return {"total_feedback_entries": 0, "learning_progress": "No feedback yet"}